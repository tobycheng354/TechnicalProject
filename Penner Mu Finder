import math
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import r2_score
from sklearn.metrics import mean_squared_error
import statistics
plt.style.use('ggplot')
plt.rcParams["font.family"] = "Times New Roman"
#data
data1 = pd.read_csv("~/Desktop/ResultsAstro.csv")
HVI1 = data1['HorizontalVelIn']
VVI1 = data1['VerticalVelIn']
SI1 = data1['SpinIn']
HVO1 = data1['HorizontalVelOut']
VVO1 = data1['VerticalVelOut']
SO1 = data1['SpinOut']
n1 = len(data1)
data2 = pd.read_csv("~/Desktop/ResultsCourse.csv")
HVI2 = data2['HorizontalVelIn']
VVI2 = data2['VerticalVelIn']
SI2 = data2['SpinIn']
HVO2 = data2['HorizontalVelOut']
VVO2 = data2['VerticalVelOut']
SO2 = data2['SpinOut']
n2 = len(data2)


n = 100
mu_vals = np.linspace(0, 1, n)
r = 0.0202

errors_course = []
errors_astro = []
for mu in mu_vals:
    output_x_velocities1 = []
    output_y_velocities1 = []
    output_a_velocities1 = []
    for i in range(0, n1):
        #inputs
        ix = HVI1[i]
        iy = VVI1[i]
        iw = SI1[i]
        vel = (math.sqrt((HVI1[i]*HVI1[i]) + (VVI1[i]*VVI1[i])))
        vel_dir = math.atan(VVI1[i]/HVI1[i])
        
        ang = 15.4 * (vel / 18.6)  * (math.degrees(vel_dir) / 44.4)
        theta = math.radians(ang)
        ixdash = (ix * math.cos(theta)) - (abs(iy) * math.sin(theta))
        iydash = (ix * math.sin(theta)) + (abs(iy) * math.cos(theta))
        
        if abs(iy) <= 20:
            e = 0.510 - (0.0375 * abs(iydash)) + (0.000903 * abs(iydash) * abs(iydash))
        else:
            e = 0.120        

        #slip/roll
        mu_c = (2*(ixdash + (r*iw)))/(7*(1+e)*(iydash))  
        if mu <= mu_c: #bounce
            rxdash = ixdash - ((mu * abs(iydash))*(1+e))
            rydash = e * abs(iydash)
            rw = iw - (((5*mu)/(2*r))*(abs(iydash))*(1+e))
        else: #roll
            rxdash = ((5/7)*ixdash) - ((2/7)*r*iw)
            rydash = e*abs(iydash)
            rw = -rxdash/r
        
        #output
        rx = (rxdash * math.cos(theta)) - (rydash * math.sin(theta))
        ry = (rxdash * math.sin(theta)) + (rydash * math.cos(theta))
        output_x_velocities1.append(rx)
        output_y_velocities1.append(ry)
        output_a_velocities1.append(rw)
    MSD_x1 = mean_squared_error(HVO1, output_x_velocities1, squared = False)/abs(statistics.mean(HVO1))
    MSD_y1 = mean_squared_error(VVO1, output_y_velocities1, squared = False)/abs(statistics.mean(VVO1))
    MSD_a1 = mean_squared_error(SO1, output_a_velocities1, squared = False)/abs(statistics.mean(SO1))
    errors_astro.append(MSD_x1 + MSD_y1 + MSD_a1)


    
for mu in mu_vals:
    output_x_velocities2 = []
    output_y_velocities2 = []
    output_a_velocities2 = []
    for i in range(0, n2):
        #inputs
        ix = HVI2[i]
        iy = VVI2[i]
        iw = SI2[i]
        vel = (math.sqrt((HVI2[i]*HVI2[i]) + (VVI2[i]*VVI2[i])))
        vel_dir = math.atan(VVI2[i]/HVI2[i])
        
        ang = 15.4 * (vel / 18.6)  * (math.degrees(vel_dir) / 44.4)
        theta = math.radians(ang)
        ixdash = (ix * math.cos(theta)) - (abs(iy) * math.sin(theta))
        iydash = (ix * math.sin(theta)) + (abs(iy) * math.cos(theta))
        
        if abs(iy) <= 20:
            e = 0.510 - (0.0375 * abs(iydash)) + (0.000903 * abs(iydash) * abs(iydash))
        else:
            e = 0.120   

        #slip/roll
        mu_c = (2*(ixdash + (r*iw)))/(7*(1+e)*(iydash))  
        if mu <= mu_c: #bounce
            rxdash = ixdash - ((mu * abs(iydash))*(1+e))
            rydash = e * abs(iydash)
            rw = iw - (((5*mu)/(2*r))*(abs(iydash))*(1+e))
        else: #roll
            rxdash = ((5/7)*ixdash) - ((2/7)*r*iw)
            rydash = e*abs(iydash)
            rw = -rxdash/r
        
        #output
        rx = (rxdash * math.cos(theta)) - (rydash * math.sin(theta))
        ry = (rxdash * math.sin(theta)) + (rydash * math.cos(theta))
        output_x_velocities2.append(rx)
        output_y_velocities2.append(ry)
        output_a_velocities2.append(rw)
        
    MSD_x2 = mean_squared_error(HVO2, output_x_velocities2, squared = False)/abs(statistics.mean(HVO2))
    MSD_y2 = mean_squared_error(VVO2, output_y_velocities2, squared = False)/abs(statistics.mean(VVO2))
    MSD_a2 = mean_squared_error(SO2, output_a_velocities2, squared = False)/abs(statistics.mean(SO2))
    errors_course.append(MSD_x2 + MSD_y2 + MSD_a2)


fig, axs = plt.subplots(1,2,figsize=(15, 15))

axs[0].plot(mu_vals, errors_astro)
axs[0].set_box_aspect(1)
axs[0].set_ylim([5, 10])
axs[0].set_xlim([0, 1])
axs[0].set(xlabel = 'Coefficient of Friction '+r"$(\mu)$", ylabel = r"$\sum$"+"NRMSE")

axs[1].plot(mu_vals, errors_course)
axs[1].set_box_aspect(1)
axs[1].set_xlim([0, 1])
axs[1].set_ylim([5, 10])
axs[1].set(xlabel = 'Coefficient of Friction '+r"$(\mu)$", ylabel = r"$\sum$"+"NRMSE")
